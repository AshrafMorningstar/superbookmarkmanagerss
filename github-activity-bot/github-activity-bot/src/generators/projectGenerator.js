/*
 Copyright (c) 2026 Ashraf Morningstar
 These are personal recreations of existing projects, developed by Ashraf Morningstar
 for learning and skill development.
 Original project concepts remain the intellectual property of their respective creators.
 Repository: https://github.com/AshrafMorningstar
*/

import { logger } from "../utils/logger.js";

const AUTHOR_NAME = "Ashraf Morningstar";
const AUTHOR_LINK = "https://github.com/AshrafMorningstar";

const CREDITS_MD = `# Project Credits

This project was generated by GitHub Activity Bot

Created by: ${AUTHOR_NAME}
GitHub: ${AUTHOR_LINK}

## Note
This is an automated project generation for demonstration purposes.
All generated content is properly attributed and marked as automated.
`;

function randomId(prefix = "id") {
  return `${prefix}_${Math.random().toString(36).substring(2, 8)}`;
}

function realisticJSExample() {
  const fn = randomId("calc");
  return `// ${fn} - simple example function\nfunction ${fn}(a, b) {\n  // simple add with input validation\n  if (typeof a !== 'number' || typeof b !== 'number') {\n    throw new TypeError('expected numbers');\n  }\n  return a + b;\n}\n\nexport default ${fn};\n`;
}

function realisticPythonExample() {
  const fn = randomId("compute");
  return `"""Simple ${fn} example"""\n\ndef ${fn}(a, b):\n    """Adds two numbers with basic checks"""\n    try:\n        return float(a) + float(b)\n    except Exception as e:\n        raise ValueError('invalid inputs') from e\n\nif __name__ == '__main__':\n    print(${fn}(1, 2))\n`;
}

function realisticHTMLExample() {
  return `<!doctype html>\n<html lang="en">\n<head>\n  <meta charset="utf-8">\n  <meta name="viewport" content="width=device-width,initial-scale=1">\n  <title>Generated Project</title>\n  <link rel="stylesheet" href="styles.css">\n</head>\n<body>\n  <h1>Generated Project</h1>\n  <p>Created by ${AUTHOR_NAME} - <a href="${AUTHOR_LINK}">GitHub</a></p>\n  <script src="main.js"></script>\n</body>\n</html>`;
}

function realisticCSSExample() {
  return `body {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;\n  margin: 0; padding: 24px; background: #f6f8fa; color: #24292e;\n}\n`;
}

function realisticReadme(projectName) {
  return `# ${projectName}\n\nThis is an automatically generated sample project created by the GitHub Activity Bot.\n\n## Credits\nGenerated by: ${AUTHOR_NAME} (${AUTHOR_LINK})\n`;
}

function makeFileFooter() {
  return `\n\n/*\nCredits: ${AUTHOR_NAME} - ${AUTHOR_LINK}\nThis file was generated by an automated bot for demonstration purposes.\n*/`;
}

function generateFilesForType(type) {
  // Return an object mapping relative paths -> content
  const files = {};
  const base = `${type}`;
  const projectName = `${type}-sample`;

  // Common files
  files[`${base}/README.md`] = realisticReadme(projectName) + "\n" + CREDITS_MD;
  files[`${base}/CREDITS.md`] = CREDITS_MD;
  files[`${base}/.gitignore`] = `node_modules\n.DS_Store\n/dist\n`;

  // Web
  files[`${base}/index.html`] = realisticHTMLExample();
  files[`${base}/styles.css`] = realisticCSSExample();
  files[`${base}/main.js`] = realisticJSExample() + makeFileFooter();

  // Backend examples
  files[`${base}/app.py`] = realisticPythonExample() + makeFileFooter();
  files[`${base}/script.sh`] =
    `#!/bin/bash\necho "Hello from generated script"\n` + makeFileFooter();

  // Other languages
  files[`${base}/Example.java`] =
    `public class Example {\n    public static void main(String[] args) {\n        System.out.println("Hello from Java");\n    }\n}\n` +
    makeFileFooter();
  files[`${base}/example.cpp`] =
    `#include <iostream>\nint main() { std::cout << "Hello from C++" << std::endl; return 0; }\n` +
    makeFileFooter();
  files[`${base}/example.rb`] = `puts 'Hello from Ruby'\n` + makeFileFooter();
  files[`${base}/example.php`] =
    `<?php\necho 'Hello from PHP';\n?>\n` + makeFileFooter();
  files[`${base}/example.go`] =
    `package main\nimport "fmt"\nfunc main(){ fmt.Println("Hello from Go") }\n` +
    makeFileFooter();
  files[`${base}/example.rs`] =
    `fn main() { println!("Hello from Rust"); }\n` + makeFileFooter();
  files[`${base}/query.sql`] =
    `-- sample SQL\nCREATE TABLE sample(id INT PRIMARY KEY, name TEXT);\n` +
    makeFileFooter();
  files[`${base}/notes.md`] =
    `# Notes\nGenerated sample project ${projectName}\n` + makeFileFooter();

  return files;
}

function conventionalCommitMessage(type, action, target) {
  // type: feat, fix, docs, chore, refactor, test
  // action: add/update/remove
  // target: what changed
  return `${type}(${target}): ${action} ${target}`;
}

export class ProjectGenerator {
  constructor(githubClient) {
    this.github = githubClient;
    // keep a list of simple project type names
    this.availableTypes = [
      "calculator",
      "todo",
      "portfolio",
      "shopping",
      "example",
    ];
  }

  // generateContent(mode, projectTypes, commitDate)
  // commitDate may be null (now) or a Date object for historical commits
  async generateContent(mode, projectTypes, commitDate = null, options = {}) {
    try {
      if (mode === "single") {
        await this._generateSingleRepo(projectTypes, commitDate, options);
      } else {
        await this._generateMultipleRepos(projectTypes, commitDate, options);
      }
    } catch (error) {
      logger.error("Failed to generate content:", error);
      throw error;
    }
  }

  async _generateSingleRepo(projectTypes, commitDate, options) {
    const repoName = options.repoName || `multi-project-${Date.now()}`;

    // If an existing repo/owner are provided, use them
    if (options.existingOwner && options.existingRepo) {
      const owner = options.existingOwner;
      const existingRepo = options.existingRepo;

      // Add credits file
      await this.github.createCommit(
        owner,
        existingRepo,
        { ["CREDITS.md"]: CREDITS_MD },
        conventionalCommitMessage("docs", "add", "CREDITS"),
        { name: AUTHOR_NAME, email: process.env.AUTHOR_EMAIL },
        commitDate
      );

      for (const type of projectTypes) {
        const files = generateFilesForType(type);
        const commitMsg = conventionalCommitMessage("feat", "add", type);
        await this.github.createCommit(
          owner,
          existingRepo,
          files,
          commitMsg,
          { name: AUTHOR_NAME, email: process.env.AUTHOR_EMAIL },
          commitDate
        );
      }
      return;
    }

    // Otherwise create a new repo and populate
    const repo = await this.github.createRepo(
      repoName,
      "Collection of generated projects [automated]"
    );

    // Add credits file as a single commit
    await this.github.createCommit(
      repo.owner.login,
      repoName,
      { ["CREDITS.md"]: CREDITS_MD },
      conventionalCommitMessage("docs", "add", "CREDITS"),
      { name: AUTHOR_NAME, email: process.env.AUTHOR_EMAIL },
      commitDate
    );

    // Generate each project in its own directory and commit them grouped per project
    for (const type of projectTypes) {
      const files = generateFilesForType(type);
      const commitMsg = conventionalCommitMessage("feat", "add", type);
      await this.github.createCommit(
        repo.owner.login,
        repoName,
        files,
        commitMsg,
        { name: AUTHOR_NAME, email: process.env.AUTHOR_EMAIL },
        commitDate
      );
    }
  }

  async _generateMultipleRepos(projectTypes, commitDate, options) {
    for (const type of projectTypes) {
      const repoName = options.repoPrefix
        ? `${options.repoPrefix}-${type}-${Date.now()}`
        : `${type}-project-${Date.now()}`;
      const repo = await this.github.createRepo(
        repoName,
        `Generated ${type} project [automated]`
      );

      // Add credits and all files in a single commit for realism
      const files = generateFilesForType(type);
      files["CREDITS.md"] = CREDITS_MD;
      const commitMsg = conventionalCommitMessage("feat", "add", type);
      await this.github.createCommit(
        repo.owner.login,
        repoName,
        files,
        commitMsg,
        { name: AUTHOR_NAME, email: process.env.AUTHOR_EMAIL },
        commitDate
      );
    }
  }
}
